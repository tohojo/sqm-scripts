#!/bin/sh

# This script implements a 3 queue traffic classification system on egress and
# single queue on ingress. It is built specifically for NAT/Masquerade gateways.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.

. ${SQM_LIB_DIR}/defaults.sh

#PRIORITY traffic is guaranteed 40% of the bandwidth and capped to max 30%.
PRIO=$(( ${UPLINK} * 40 / 100 ))
#NORMAL is given a link share target of 40% with guarantee resulting in
#a 2:1 bandwidth allocation vs BULK which is given a target of 20%.
NORMAL=$(( ${UPLINK} * 40 / 100 ))
BULK=$(( ${UPLINK} * 20 / 100 ))

#Maximum delay of a single packet transmit in the priority queue.
#Value in 1/10th ms. Default set to 0.9 ms.
MAX_PDELAY_PRIO=9
#Derived maximum single packet size in the priority queue.
MAX_PSIZE_PRIO=$(( ${PRIO} * ${MAX_PDELAY_PRIO} / 8 / 10 ))

ipt_setup() {
    ipt -t mangle -F QOS_MARK_${IFACE}
    ipt -t mangle -X QOS_MARK_${IFACE}
    ipt -t mangle -N QOS_MARK_${IFACE}

    ipt -t mangle -F QOS_RULES_${IFACE}
    ipt -t mangle -X QOS_RULES_${IFACE}
    ipt -t mangle -N QOS_RULES_${IFACE}

    ipt -t mangle -A POSTROUTING -o ${IFACE} -g QOS_MARK_${IFACE}

    ipt -t mangle -A QOS_MARK_${IFACE} -j CONNMARK \
    --restore-mark --nfmask ${IPT_MASK} --ctmask ${IPT_MASK}
    ipt -t mangle -A QOS_MARK_${IFACE} -m mark --mark 0x00${IPT_MASK_STRING} \
    -j QOS_RULES_${IFACE}

    #Classify known interactive services in the NORMAL queue.
    ipt -t mangle -A QOS_RULES_${IFACE} -p tcp -m multiport \
    --ports ftp,ssh,http,https,smtp,smtps,pop3,pop3s,imap,imaps \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    ipt -t mangle -A QOS_RULES_${IFACE} -p icmp \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    #Assign DNS and NTP to PRIORITY.
    ipt -t mangle -A QOS_RULES_${IFACE} -p udp -m multiport \
    --ports domain,time,ntp -j MARK --set-mark 0x01${IPT_MASK_STRING}
    #Everything else is marked for BULK.
    ipt -t mangle -A QOS_RULES_${IFACE} -m mark --mark 0x00${IPT_MASK_STRING} \
    -j MARK --set-mark 0x03${IPT_MASK_STRING}
    ipt -t mangle -A QOS_RULES_${IFACE} -j CONNMARK \
    --save-mark --nfmask ${IPT_MASK} --ctmask ${IPT_MASK}

    #DSCP Individual packet override.
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class EF \
    -j MARK --set-mark 0x01${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF41 \
    -j MARK --set-mark 0x01${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF42 \
    -j MARK --set-mark 0x01${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF43 \
    -j MARK --set-mark 0x01${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS6 \
    -j MARK --set-mark 0x01${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS5 \
    -j MARK --set-mark 0x01${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS4 \
    -j MARK --set-mark 0x01${IPT_MASK_STRING}

    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF31 \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF32 \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF33 \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF21 \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF22 \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF23 \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS3 \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS2 \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}

    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF11 \
    -j MARK --set-mark 0x03${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF12 \
    -j MARK --set-mark 0x03${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF13 \
    -j MARK --set-mark 0x03${IPT_MASK_STRING}
    ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS1 \
    -j MARK --set-mark 0x03${IPT_MASK_STRING}

    #Reclass of large packets.
    ipt -t mangle -A QOS_MARK_${IFACE} -m mark --mark 0x01${IPT_MASK_STRING} \
    -m length --length ${MAX_PSIZE_PRIO}:0xffff \
    -j MARK --set-mark 0x02${IPT_MASK_STRING}
}

egress() {
    $TC qdisc del dev ${IFACE} root 2> /dev/null
    $TC qdisc add dev ${IFACE} root handle 1: `get_stab_string` hfsc default 13

    $TC class add dev ${IFACE} parent 1: classid 1:1 hfsc sc rate ${UPLINK}kbit \
    ul rate ${UPLINK}kbit

    $TC class add dev ${IFACE} parent 1:1 classid 1:11 hfsc sc rate ${PRIO}kbit \
    ul rate ${PRIO}kbit
    $TC class add dev ${IFACE} parent 1:1 classid 1:12 hfsc sc rate ${NORMAL}kbit
    $TC class add dev ${IFACE} parent 1:1 classid 1:13 hfsc sc rate ${BULK}kbit

    $TC qdisc add dev ${IFACE} parent 1:11 handle 110: ${QDISC} \
    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
    `get_quantum  300` `get_flows ${PRIO}` ${EQDISC_OPTS}
    $TC qdisc add dev ${IFACE} parent 1:12 handle 120: ${QDISC} \
    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
    `get_quantum  300` `get_flows ${NORMAL}` ${EQDISC_OPTS}
    $TC qdisc add dev ${IFACE} parent 1:13 handle 130: ${QDISC} \
    `get_limit ${ELIMIT}` `get_target "${ETARGET}" ${UPLINK}` `get_ecn ${EECN}` \
    `get_quantum  300` `get_flows ${BULK}` ${EQDISC_OPTS}

    #FLOW qdisc ensures that on Xfq_codel flows are taking pre-nat informations.
    $TC filter add dev ${IFACE} parent 110: handle 110 protocol all \
    flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst \
    divisor `get_flows_count ${PRIO}`
    $TC filter add dev ${IFACE} parent 120: handle 120 protocol all \
    flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst \
    divisor `get_flows_count ${NORMAL}`
    $TC filter add dev ${IFACE} parent 130: handle 130 protocol all \
    flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst \
    divisor `get_flows_count ${BULK}`

    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 1 u32 \
    match mark 0x01 ${IPT_MASK} flowid 1:11
    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 \
    match mark 0x02 ${IPT_MASK} flowid 1:12
    $TC filter add dev ${IFACE} parent 1:0 protocol all prio 2 u32 \
    match mark 0x03 ${IPT_MASK} flowid 1:13
}

ingress() {
    $TC qdisc del dev ${IFACE} handle ffff: ingress 2> /dev/null
    $TC qdisc add dev ${IFACE} handle ffff: ingress

    $TC qdisc del dev ${DEV} root 2> /dev/null
    $TC qdisc add dev ${DEV} root handle 1: `get_stab_string` hfsc default 1

    #Use a single queue for ingress.
    $TC class add dev ${DEV} parent 1: classid 1:1 hfsc sc rate ${DOWNLINK}kbit \
    ul rate ${DOWNLINK}kbit

    $TC qdisc add dev ${DEV} parent 1:1 handle 11: ${QDISC} `get_limit ${ILIMIT}` \
    `get_target "${ITARGET}" ${DOWNLINK}` `get_ecn ${IECN}` `get_quantum  1540` \
    `get_flows ${DOWNLINK}` ${IQDISC_OPTS}

    $TC filter add dev ${DEV} parent 11: handle 11 protocol all \
    flow hash keys nfct-src,nfct-dst,nfct-proto,nfct-proto-src,nfct-proto-dst \
    divisor `get_flows_count ${DOWNLINK}`

    $IP link set dev ${DEV} up

    $TC filter add dev ${IFACE} parent ffff: protocol all prio 1 u32 \
    match u32 0 0 action mirred egress redirect dev ${DEV}
}

sqm_start() {
    [ -n "${IFACE}" ] || return 1
    do_modules
    verify_qdisc "hfsc" || return 1
    verify_qdisc ${QDISC} || return 1
    sqm_logger "Starting ${SCRIPT}"

    eth_setup
    ipt_setup

    [ -z "$DEV" ] && DEV=$( get_ifb_for_if ${IFACE} )

    if [ "${UPLINK}" -ne 0 ];
    then
        egress
        sqm_logger "egress shaping activated"
    else
        sqm_logger "egress shaping deactivated"
        $TC qdisc del dev ${IFACE} root 2> /dev/null
    fi
    if [ "${DOWNLINK}" -ne 0 ];
    then
        verify_qdisc ingress "ingress" || return 1
        ingress
        sqm_logger "ingress shaping activated"
    else
        sqm_logger "ingress shaping deactivated"
        $TC qdisc del dev ${DEV} root 2> /dev/null
        $TC qdisc del dev ${IFACE} ingress 2> /dev/null
    fi

    return 0
}

sqm_stop() {
    $TC qdisc del dev ${IFACE} ingress 2> /dev/null
    $TC qdisc del dev ${IFACE} root 2> /dev/null
    [ -n "$CUR_IFB" ] && $TC qdisc del dev ${CUR_IFB} root 2> /dev/null
    [ -n "$CUR_IFB" ] && sqm_logger "${0}: ${CUR_IFB} shaper deleted"

    ipt -t mangle -D POSTROUTING -o ${IFACE} -g QOS_MARK_${IFACE}
    ipt -t mangle -F QOS_MARK_${IFACE}
    ipt -t mangle -X QOS_MARK_${IFACE}
    ipt -t mangle -F QOS_RULES_${IFACE}
    ipt -t mangle -X QOS_RULES_${IFACE}

    [ -n "$CUR_IFB" ] && $IP link set dev ${CUR_IFB} down
    [ -n "$CUR_IFB" ] && $IP link delete ${CUR_IFB} type ifb
    [ -n "$CUR_IFB" ] && sqm_logger "${0}: ${CUR_IFB} interface deleted"
}
